// ===== Banner: solo refresca TEXTO, sin reemplazar DOM =====
const $  = sel => document.querySelector(sel);
const cityEl = $('#b-city');
const tempEl = $('#b-temp');
const clockEl = $('#b-clock');

function hhmm(){
  return new Date().toLocaleTimeString('es-AR', {hour:'2-digit', minute:'2-digit', hour12:false});
}
function setText(el, txt){
  if (!el) return;
  if (el.textContent !== String(txt)) {
    el.textContent = String(txt);
    el.classList.remove('text-tick'); // retrigger simple highlight
    // force reflow
    void el.offsetWidth;
    el.classList.add('text-tick');
  }
}

async function fetchJSON(url, {timeoutMs=8000}={}){
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), timeoutMs);
  try{
    const r = await fetch(url, {cache:'no-store', signal: ctrl.signal});
    if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  } finally { clearTimeout(t); }
}

async function getConfig(){
  const cfg = await fetchJSON('/api/overlay/config').catch(()=>({}));
  return {
    cities: cfg.cities || [],
    labels: cfg.labels || {},
    cycle: Math.max(2, parseInt(cfg.cycle || 15, 10)),
    liveEvery: Math.max(1, parseInt(cfg.live_every || 5, 10)),
  };
}
function displayNameFor(it, labels){ return (labels && labels[it.ciudad]) || it.ciudad; }

async function getItems(cities){
  const qs = new URLSearchParams({ cities: (cities||[]).join(',') });
  const data = await fetchJSON('/api/weather?' + qs).catch(()=>({}));
  return (data && data.items) ? data.items : [];
}

(async function main(){
  const cfg = await getConfig();
  const cities = cfg.cities, labels = cfg.labels;
  const cycle  = cfg.cycle,  liveEvery = cfg.liveEvery;

  let items = await getItems(cities);
  // mantener orden de cities
  const order = new Map(cities.map((c,i)=>[String(c).toLowerCase(), i]));
  items.sort((a,b)=> (order.get((a.ciudad||'').toLowerCase()) ?? 999) - (order.get((b.ciudad||'').toLowerCase()) ?? 999));

  // Primer render
  if (items.length){
    const it = items[0];
    setText(cityEl, displayNameFor(it, labels));
    setText(tempEl, (it.temperatura ?? '—') + '°C');
  } else {
    setText(cityEl, 'EN VIVO');
    setText(tempEl, hhmm());
  }
  setText(clockEl, hhmm());

  // Reloj (solo texto)
  setInterval(()=> setText(clockEl, hhmm()), 5_000);

  // Rotación (solo texto)
  let idx = 1 % Math.max(items.length,1);
  let sinceLive = 1;
  setInterval(()=>{
    if (sinceLive >= liveEvery){
      setText(cityEl, 'EN VIVO');
      setText(tempEl, hhmm());
      sinceLive = 0;
      return;
    }
    if (!items.length){
      setText(cityEl, 'EN VIVO');
      setText(tempEl, hhmm());
      return;
    }
    const it = items[idx % items.length];
    setText(cityEl, displayNameFor(it, labels));
    setText(tempEl, (it.temperatura ?? '—') + '°C');
    idx = (idx + 1) % Math.max(items.length,1);
    sinceLive++;
  }, cycle * 1000);

  // Refresco de datos (sin borrar banner)
  setInterval(async ()=>{
    try{
      const fresh = await getItems(cities);
      if (fresh && fresh.length){
        fresh.sort((a,b)=> (order.get((a.ciudad||'').toLowerCase()) ?? 999) - (order.get((b.ciudad||'').toLowerCase()) ?? 999));
        items = fresh;
        idx = idx % items.length;
      }
    }catch(e){ console.warn('refresh error', e); }
  }, 60_000);

  // Mantener dataset del backend fresco
  setInterval(async ()=>{ try{ await fetch('/api/tiepre'); }catch{} }, 5*60_000);
})();
